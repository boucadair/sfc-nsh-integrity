<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-rebo-sfc-nsh-integrity-02"
     ipr="trust200902">
  <front>
    <title abbrev="Integrity Protection for NSH">Integrity Protection for
    Network Service Header (NSH) and Encryption of Sensitive Context
    Headers</title>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>TirumaleswarReddy_Konda@McAfee.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>dwing-ietf@fuggles.com</email>
      </address>
    </author>

    <date />

    <workgroup>SFC</workgroup>

    <abstract>
      <t>This specification adds integrity protection and optional encryption
      of sensitive metadata directly to Network Service Headers (NSH) used for
      Service Function Chaining (SFC).<!-- Encapsulation of NSH within NSH

--></t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Many advanced Service Functions (e.g., Performance Enhancement
      Proxies, NATs, firewalls, etc.) are invoked for the delivery of
      value-added services, particularly to meet various service objectives
      such as IP address sharing, avoiding covert channels, detecting
      Denial-of-Service (DoS) attacks and protecting network infrastructures
      against them, network slicing, etc. Because of the proliferation of such
      advanced SFs together with complex service deployment constraints that
      demand more agile service delivery procedures, operators need to
      rationalize their service delivery logics and master their complexity
      while optimising service activation time cycles. The overall problem
      space is described in <xref target="RFC7498"></xref>.</t>

      <t><xref target="RFC7665"></xref> presents an architecture addressing
      the problematic aspects of existing service deployments, including
      topological dependence and configuration complexity. It also describes
      an architecture for the specification, creation, and maintenance of
      Service Function Chains (SFC) within a network. That is, how to define
      an ordered set of SFs and ordering constraints that must be applied to
      packets/flows selected as a result of traffic classification. <xref
      target="RFC8300"></xref> specifies the SFC encapsulation: Network
      Service Header (NSH).</t>

      <t>NSH data is unauthenticated and unencrypted <xref
      target="RFC8300"></xref>, forcing a service topology that requires
      security and privacy to use a transport encapsulation that supports such
      features (e.g., IPsec). The lack of such capability was reported during
      the development of <xref target="RFC8300"></xref> and <xref
      target="RFC8459"></xref>. The reader may refer to Section 4.2.1 of <xref
      target="I-D.arkko-arch-internet-threat-model"></xref> for a discussion
      on the need for more awareness about attacks from within closed
      domains.</t>

      <t> This specification fills that gap. Concretely, this document adds
      integrity protection and optional encryption of sensitive metadata
      directly to NSH (<xref target="overview"></xref>); integrity protects
      the packet payload, and provides relay protection. Thus, the NSH do not
      have to rely upon an underlying transport encapsulation for security and
      confidentiality. </t>

      <t>This specification introduces new Variable-Length Context Headers to
      carry fields necessary for integrity protected NSH headers and encrypted
      Context Headers (<xref target="new"></xref>), and is therefore only
      applicable to NSH MD Type 0x02, as defined in Section 2.5 of <xref
      target="RFC8300"></xref>.</t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>This document makes use of the terms defined in <xref
      target="RFC7665"></xref> and <xref target="RFC8300"></xref>.</t>

      <t>The document defines the following terms:<list style="symbols">
          <t>SFC data plane element: Refers to SFC-aware Service Function,
          Service Function Forwarder (SFF), SFC proxy, or classifier as
          defined in the SFC data plane architecture <xref
          target="RFC7665"></xref>.</t>

          <t>SFC Control Element: A logical entity that instructs one or more
          SFC data plane functional elements on how to process NSH packets
          within an SFC-enabled domain.</t>

          <t>Key Identifier: A key identifier or kerberos-like object used to
          identify and deliver keys to authorized entities.</t>

          <t>NSH data: The NSH is composed of a Base Header, a Service Path
          Header, and optional Context Headers. NSH data refers to all the
          above headers and the packet or frame on which NSH is imposed to
          realize a Service Function Path (SFP).</t>

          <t>NSH imposer: Refers to the SFC data plane element that is
          entitled to impose NSH with the Context Headers defined in this
          document.</t>
        </list></t>
    </section>

    <section anchor="req" title="Assumptions &amp; Basic Requirements">
      <t>The NSH format is defined in Section 2 of <xref
      target="RFC8300"></xref>; the NSH data can be spread over three
      headers:<list style="symbols">
          <t>Base Header: Provides information about the service header and
          the payload protocol.</t>

          <t>Service Path Header: Provides path identification and location
          within a Service Function Path (SFP).</t>

          <t>Context Header(s): Carries metadata (i.e., context data) along a
          service path.</t>
        </list></t>

      <t>NSH allows to share context information (a.k.a., metadata) with
      upstream SFC-aware data elements on a per SFC/SFP basis. To that
      aim:<list style="symbols">
          <t>The control plane is used to instruct the SFC classifier about
          the set of context information to be supplied in the context of a
          given chain.</t>

          <t>The control plane is also used to instruct an SFC-aware SF about
          any metadata it needs to attach to packets for a given SFC. This
          instruction may occur any time during the validity lifetime of an
          SFC/SFP. The control plane may indicate, for a given service
          function chain, an order for consuming a set of contexts supplied in
          a packet.</t>

          <t>An SFC-aware SF can also be instructed about the behavior it
          should adopt after consuming a context information that was supplied
          in the NSH header. For example, the context can be maintained,
          updated, or stripped.</t>

          <t>An SFC proxy may be instructed about the behavior it should adopt
          to process the context information that was supplied in the NSH
          header on behalf of an SFC-unaware SF, e.g., the context can be
          maintained or stripped.</t>

          <t>The SFC proxy may also be instructed to add some new context
          information into the NSH header on behalf of an SFC-unaware SF.</t>
        </list></t>

      <t>In reference to <xref target="op"></xref>, <list style="symbols">
          <t>Classifiers, SFC-aware SFs, and SFC proxies are entitled to
          update the context header: Only these elements MUST be able to
          encrypt and decrypt a supplied Context Header.</t>

          <t>Only SFC-aware SFs and SFC proxies are entitled to update the
          Service Path header. The solution MUST provide integrity protection
          for this header.</t>

          <t>SFFs are entitled to modify the Base Path header (TTL value, for
          example). Nevertheless, SFFs are not supposed to act on the Context
          Header or look into the content of the Context Header. The solution
          MAY provide integrity protection for the base header. The
          implications of disabling such checks are discussed in <xref
          target="mac1"></xref>.<list style="empty">
              <t>Discussion Note: This design decision should be discussed
              with the working group.</t>
            </list></t>
        </list></t>

      <t><figure align="center" anchor="op" title="NSH Actions">
          <artwork align="center"><![CDATA[+---------------+-----------------------+---------------+
|               | Insert, remove, or    | Update        |
|               | replace the NSH       | the NSH       |
|               |                       |               |
|SFC Data Plane +-------+-------+-------+-------+-------+
|   Element     |       |       |       |Dec.   |Update |
|               |Insert |Remove |Replace|Service|Context|
|               |       |       |       |Index  |Header |
+---------------+-------+-------+-------+-------+-------+
|               |  +    |       |   +   |       |   +   |
|Classifier     |       |       |       |       |       |
+---------------+-------+-------+-------+-------+-------+
|Service        |       |   +   |       |       |       |
|Function       |       |       |       |       |       |
|Forwarder (SFF)|       |       |       |       |       |
+---------------+-------+-------+-------+-------+-------+
|Service        |       |       |       |   +   |   +   |
|Function (SF)  |       |       |       |       |       |
+---------------+-------+-------+-------+-------+-------+
|               |  +    |   +   |       |   +   |   +   |
|SFC Proxy      |       |       |       |       |       |
+---------------+-------+-------+-------+-------+-------+]]></artwork>
        </figure></t>

      <t>The solution described in this document does not make any assumption
      about the service function chains to be instantiated nor adds any
      constraint about how NSH can be used within a domain. For example, in
      reference to <xref target="ex"></xref>, the solution accommodates
      deployment schemes such as: <list style="symbols">
          <t>No Context Header is inserted by the Classifier: it only proceeds
          with the NSH integrity protection. The NSH encapsulated packet is
          then forwarded to the next hop following <xref
          target="RFC7665"></xref>.</t>

          <t>Once the packet is received by SF1, and assuming integrity checks
          succeed, SF1 inserts two Context Headers M1 and M2 that it encrypts
          and recomputes the message integrity for the NSH data. </t>

          <t>Once the packet is received by SF2, and assuming integrity checks
          succeed, SF2 decrypts M1 and M2, strips M2 (because its instructed
          to do so via the SFC control plane), and then encrypts M1 and
          recomputes the message integrity for the NSH data.</t>

          <t>Once the packet is received by SF3, and assuming integrity checks
          succeed, SF3 decrypts M1, consumes the decrypted M1 data, and then
          strips it from the NSH. The packet is then forwarded back to SFF3 by
          SF3 after recomputing the message integrity for the NSH data.</t>
        </list></t>

      <t><figure anchor="ex" title="SFC-enabled Domain Example">
          <artwork align="center"><![CDATA[             SF1            SF3
              |              |
Classifier---SFF1----SFF2---SFF3
                      |
                      SF2
]]></artwork>
        </figure></t>
    </section>

    <section anchor="overview" title="Solution Overview">
      <t></t>

      <section title="Supported Security Services">
        <t>This specification provides the functions described in the
        following sub-sections:</t>

        <section title="Encrypt All or a Subset of Metadata">
          <t>The solution allows to encrypt all or a subset of metadata (that
          is carried in NSH Context Headers) by Classifiers, SFC-aware SFs,
          and SFC proxies. As depicted in <xref target="eroles"></xref>, SFFs
          are not involved in data encryption. This memo enforces this design
          approach by encrypting the Context Header which is not supplied to
          SFFs, thus enforcing this limitation by protocol (rather than
          requirements language). </t>

          <texttable align="center" anchor="eroles"
                     title="Encryption Function Supported by SFC Data Plane Elements">
            <ttcol>Data Plane Element</ttcol>

            <ttcol>Encryption</ttcol>

            <c>Classifier</c>

            <c>Yes</c>

            <c>SFF</c>

            <c>No</c>

            <c>SFC-aware SF</c>

            <c>Yes</c>

            <c>SFC Proxy</c>

            <c>Yes</c>

            <c>SFC-unaware SF</c>

            <c>No</c>
          </texttable>

          <t>The control plane is assumed to instruct the Classifier,
          SFC-aware SFs, and SFC proxy with the set of Context Headers
          (privacy-sensitive metadata, typically) that must be encrypted.
          Encryption keying material is only provided to these SFC data
          elements. In particular, SFFs are not provisioned with the
          encryption keying material.</t>

          <t>The control plane may also indicate the set of SFC data plane
          elements that are entitled to supply a given context header (e.g.,
          in reference to their identifiers as assigned within the SFC-enabled
          domain). It is out of the scope of this document to elaborate on how
          such instructions are provided to the appropriate SFC data plane
          elements, nor to detail the structure used to store the
          instructions.</t>

          <t>The Service Path Header is not encrypted because SFFs use Service
          Index (SI) in conjunction with Service Path Identifier (SPI) for
          determining the next SF in the path.</t>
        </section>

        <section title="Integrity Protection">
          <t>The solution provides integrity protection for NSH data. Two
          flavors are supported.</t>

          <t>A first flavor where all NSH data except the Base Header are
          integrity protected (<xref target="first"></xref>). In this case,
          the NSH imposer may be a Classifier, an SFC-aware SF, or an SFC
          proxy. SFFs are not thus provided with authentication material.
          Further details are discussed in <xref target="enc1"></xref>.<figure
              anchor="first" title="First Integrity Flavor">
              <artwork><![CDATA[   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
   |                Transport Encapsulation                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
   |                Base Header                            |  |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
|  |                Service Path Header                    |  S
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
|  |                Context Header(s)                      |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Original Packet / Frame                |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                          
+------Scope of integrity protected data                                                
]]></artwork>
            </figure></t>

          <t></t>

          <t>A second flavor where all NSH data, including the Base Header,
          are integrity protected (<xref target="sec"></xref>). In this case,
          the NSH imposer may be a Classifier, an SFC-aware SF, an SFF, or an
          SFC proxy. Further details are discussed in <xref
          target="enc2"></xref>.</t>

          <t><figure anchor="sec" title="Second Integrity Flavor">
              <artwork><![CDATA[   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
   |                Transport Encapsulation                |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Base Header                            |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
|  |                Service Path Header                    |  S
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
|  |                Context Header(s)                      |  |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  |                Original Packet / Frame                |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                           
+----Scope of integrity protected data 
                                              
]]></artwork>
            </figure></t>

          <t>The integrity protection scope is explicitly signaled to
          SFC-aware SFs and SFC proxies in the NSH by means of a dedicated MD
          Type (<xref target="enc"></xref>).</t>

          <t>In both flavors, the unencrypted metadata and the packet on which
          NSH is imposed are subject to integrity protection.</t>

          <t><xref target="iroles"></xref> lists the roles of SFC data plane
          elements in providing integrity protection for the NSH.</t>

          <texttable align="center" anchor="iroles"
                     title="Integrity Protection Supported by SFC Data Plane Elements">
            <ttcol>Data Plane Element</ttcol>

            <ttcol>Integrity Protection</ttcol>

            <c>Classifier</c>

            <c>Yes</c>

            <c>SFF</c>

            <c>No (first flavor); Yes (second flavor)</c>

            <c>SFC-aware SF</c>

            <c>Yes</c>

            <c>SFC Proxy</c>

            <c>Yes</c>

            <c>SFC-unaware SF</c>

            <c>No</c>
          </texttable>
        </section>
      </section>

      <section title="One Secret Key, Two Security Services ">
        <t>The authenticated encryption algorithm defined in <xref
        target="RFC7518"></xref> is used to provide NSH data integrity and to
        encrypt Context Headers carrying privacy-sensitive metadata. The
        authenticated encryption algorithm provides a unified encryption and
        authentication operation which turns plaintext into authenticated
        ciphertext and vice versa. The generation of secondary keys MAC_KEY
        and ENC_KEY from the secret key K is discussed in Section 5.2.2.1 of
        <xref target="RFC7518"></xref>. The ENC_KEY is used for encrypting the
        Context Headers and the message integrity of the NSH data is
        calculated using the MAC_KEY. If the Context Headers are not
        encrypted, the Hashed Message Authentication Mode (HMAC) algorithm
        discussed in <xref target="RFC4868"></xref> is used to integrity
        protect the NSH data.</t>

        <t>The advantage of using the authenticated encryption algorithm is
        that SFC-aware SFs and SFC proxies only need to re-compute the message
        integrity of the NSH data after decrementing the Service Index (SI)
        and do not have to re-compute the ciphertext. The other advantage is
        in both the flavors discussed above is SFFs do not have access to the
        ENC_KEY and cannot act on the encrypted Context Headers and, only in
        case of the second flavor, SFFs do have access to the MAC_KEY.
        Similarly, an SFC-aware SF or SFC proxy not allowed to decrypt the
        Context Headers will not have access to the ENC_KEY.</t>

        <t>The authenticated encryption algorithm or HMAC algorithm to be used
        by SFC data plane elements is typically controlled using the SFC
        control plane. Mandatory to implement authenticated encryption and
        HMAC algorithms are listed in <xref target="mti"></xref>.</t>

        <t>The authenticated encryption process takes as input four octet
        strings: a secret key K, a plaintext P, Additional Authenticated Data
        A (which contains the data to be authenticated, but not encrypted),
        and an Initialization Vector IV. The ciphertext value E and the
        Authentication Tag value T are provided as outputs. In order to
        decrypt and verify, the cipher takes as input K, IV, A, T and E. The
        output is either the plaintext or an error indicating that the
        decryption failed as described in Section 5.2.2.2 of <xref
        target="RFC7518"></xref>.</t>
      </section>

      <section anchor="mti"
               title="Mandatory-to-Implement Authenticated Encryption and HMAC Algorithms">
        <t>Classifiers, SFC-aware SFs, and SFC proxies MUST implement the
        AES_128_CBC_HMAC_SHA_256 algorithm and SHOULD implement the
        AES_192_CBC_HMAC_SHA_384 and AES_256_CBC_HMAC_SHA_512 algorithms.</t>

        <t>Classifiers, SFC-aware SFs, and SFC proxies MUST implement the
        HMAC-SHA-256-128 algorithm and SHOULD implement the HMAC-SHA-384-192
        and HMAC-SHA-512-256 algorithms.</t>

        <t>SFFs MAY implement the aforementioned cipher suites and HMAC
        algorithms.</t>
      </section>

      <section title="Key Management">
        <t>The procedure for the allocation/provisioning of secret keys (K)
        and authenticated encryption algorithm or MAC_KEY and HMAC algorithm
        is outside the scope of this specification. As such, this
        specification does not mandate the support of any specific
        mechanism.</t>

        <t>The documents does not assume nor preclude the following:<list
            style="symbols">
            <t>The same keying material is used for all the service functions
            used within an SFC-enabled domain.</t>

            <t>Distinct keying material is used per SFP.</t>

            <t>Per-tenant keys are used.</t>
          </list></t>

        <t>In order to accommodate deployments relying upon keying material
        per SFC/SFP and also the need to update keys after encrypting NSH data
        for certain amount of time, this document uses key identifier (kid) to
        unambiguously identify the appropriate keying material. Doing so
        allows to address the problem of synchronization of keying
        material.</t>

        <t>A (non-normative) sample deployment case to illustrate how kids are
        assigned is provided in <xref target="example"></xref>. Additional
        information on manual vs. automated key management and when one should
        be used over the other can be found in <xref
        target="RFC4107"></xref>.</t>
      </section>

      <section title="New NSH Variable-Length Context Headers">
        <t>New NSH Variable-Length Context Headers are defined in <xref
        target="new"></xref> for NSH data integrity protection and,
        optionally, encryption of Context Headers carrying privacy-sensitive
        metadata. Concretely, an NSH imposer includes (1) the key identifier
        in NSH using the Key Identifier Context Header (<xref
        target="id"></xref>), (2) the timestamp in Timestamp Context Header to
        protect against replay attacks (<xref target="time"></xref>), and (3)
        the Message Authentication Code (MAC) for the target NSH data
        (depending on the integrity protection scope) calculated using the
        MAC_KEY and optionally Context Headers encrypted using ENC_KEY in 'MAC
        and Encrypted Metadata Context' Header (<xref
        target="enc"></xref>).</t>

        <t>An NSH data plane element that needs to check the integrity of the
        NSH data uses the MAC_KEY and the HMAC algorithm for the key
        identifier being carried in the NSH.</t>

        <t>An SFC-aware SF or SFC proxy that needs to decrypt the metadata
        uses ENC_Key and the decryption algorithm for the key identifier being
        carried in the NSH.</t>

        <t><xref target="prorules"></xref> specifies the detailed
        procedure.</t>
      </section>

      <section title="Encapsulation of NSH within NSH">
        <t>As discussed in <xref target="RFC8459"></xref>, an SFC-enabled
        domain (called, upper-level domain) may be decomposed into many
        sub-domains (called, lower-level domains). In order to avoid
        maintaining state to restore back upper-lower NSH information at the
        boundaries of lower-level domains, two NSH levels are used: an
        Upper-NSH which imposed at the boundaries of the upper-level domain,
        and a Lower-NSH that is pushed by the Classifier of a lower-level
        domain in front of the original NSH (<xref target="nest"></xref>). As
        such, the Upper-NSH information is carried along the lower-level chain
        without modification. The packet is forwarded in the top-level domain
        according to the Upper-NSH, while it is forwarded according to the
        Lower-NSH in a lower-level SFC domain.</t>

        <t><figure anchor="nest" title="Encapsulation of NSH within NSH">
            <artwork><![CDATA[                    +---------------------------------+
                    |  Outer-Transport Encapsulation  |
                    +---------------------------------+
                    |        Lower-NSH Header         |
                    +---------------------------------+
                    |        Upper-NSH Header         |
                    +---------------------------------+
                    |          Original Packet        |
                    +---------------------------------+
]]></artwork>
          </figure></t>

        <t>SFC data plane elements of a lower-level domain includes the
        Upper-NSH when computing the MAC. </t>

        <t>Keying material used at the upper-level domain should not the same
        as the one used by a lower-level domain.</t>
      </section>
    </section>

    <section anchor="new" title="New NSH Variable-Length Context Headers">
      <t>This section specifies the format of new Variable-Length Context
      headers that are used for NSH integrity protection and, optionally,
      Context Headers encryption.</t>

      <section anchor="id" title="Key Identifier Context Header">
        <t>The Key Identifier Context Header (<xref target="fig-id"></xref>)
        is a variable length Key Identifier object used to identify and
        deliver keys to SFC data plane elements. Sending this Context Header
        is REQUIRED for compliance with this specification.</t>

        <t>This Context Header is helpful to accommodate deployments relying
        upon keying material per SFC/SFP. The key identifier helps in
        resolving the problem of synchronization of keying material.</t>

        <figure anchor="fig-id" title="Key Identifier Context Header">
          <artwork><![CDATA[      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Metadata Class       |      Type     |U|    Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                           Key Identifier                      |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ]]></artwork>
        </figure>

        <t></t>

        <t>The description of the fields is as follows:<list style="symbols">
            <t>Metadata Class: MUST be set to 0x0 <xref
            target="RFC8300"></xref>.</t>

            <t>Type: TBD1 (See <xref target="IANA"></xref>)</t>

            <t>U: Unassigned bit <xref target="RFC8300"></xref>.</t>

            <t>Length: Variable.</t>

            <t>Key Identifier: Carries the key identifier.</t>
          </list></t>
      </section>

      <section anchor="sequence" title="Timestamp Context Header">
        <t>The Timestamp Context Header (<xref target="fig-seq"></xref>)
        conveys a 64-bit timestamp value. Sending this Context Header is
        REQUIRED for compliance with this specification.</t>

        <t><figure anchor="fig-seq" title="Sequence Number Context Header">
            <artwork><![CDATA[      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Metadata Class       |      Type     |U|    Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Timestamp                              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure></t>

        <t>The description of the fields is as follows:<list style="symbols">
            <t>Metadata Class: MUST be set to 0x0 <xref
            target="RFC8300"></xref>.</t>

            <t>Type: TBD2 (See <xref target="IANA"></xref>)</t>

            <t>U: Unassigned bit <xref target="RFC8300"></xref>.</t>

            <t>Length: 8 bytes</t>

            <t>Timestamp: Carries an unsigned 64-bit integer value that is
            expressed in seconds relative to 1970-01-01T00:00Z in UTC
            time.</t>
          </list></t>
      </section>

      <section anchor="enc" title="MAC and Encrypted Metadata Context Header">
        <t>This section defines two MAC and Encrypted Metadata Context
        Headers; each having specific deployment constraints. Unlike the
        flavor discussed in <xref target="enc1"></xref>, the flavor sketched
        in <xref target="enc2"></xref> requires sharing MAC_KEY with SFFs.
        Both TLVs have the same format as shown in <xref
        target="enc"></xref>.</t>

        <t><figure anchor="mac"
            title="MAC and Encrypted Metadata Context Header">
            <artwork><![CDATA[        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Metadata Class       |      Type     |U|    Length   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | IV Length    |                                                |
       +-+-+-+-+-+-+-+-+      Initialization Vector                    ~
       ~                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       |     Message Authentication Code and optional Encrypted        |
       ~                   Context Headers                             ~
       |                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure></t>

        <t>The description of the fields is provided in the following
        sub-sections.</t>

        <section anchor="enc1" title="MAC#1 Context Header">
          <t>MAC#1 Context Header is a variable-length TLV that carries the
          Message Authentication Code (MAC) for the Service Path Header,
          Context Headers, and the inner packet on which NSH is imposed,
          calculated using MAC_KEY and optionally Context Headers encrypted
          using ENC_KEY. The scope of this TLV is depicted in <xref
          target="scope1"></xref>.</t>

          <t>This MAC flavor does not require sharing MAC_KEY with SFFs. It
          does not require to re-compute the MAC by each SFF because of TTL
          processing. <xref target="mac1"></xref> discusses the possible
          threat associated with this flavor.</t>

          <figure anchor="scope1" title="Scope of MAC#1">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |    
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
   |          Service Path Identifier              | Service Index |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Key Identifier                           ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Timestamp                                ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |                                                               |   |
   ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
   |                                                               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Metadata Class       |      Type     |U|    Length   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | IV Length   |           Initialization Vector                 |   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
|  ~              Context Header TLVs to encrypt                   ~   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   | 
|  |                                                               |   |
|  ~               Inner Packet on which NSH is imposed            ~   |
|  |                                                               |   |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
|                                                                      |
|                                                                      |
|                                                                      | 
|                                       Integrity protected Portion----+
+----Encrypted Portion                                                                
]]></artwork>
          </figure>

          <t></t>

          <t>In reference to <xref target="mac"></xref>, the description of
          the fields is as follows:<list style="symbols">
              <t>Metadata Class: MUST be set to 0x0 <xref
              target="RFC8300"></xref>.</t>

              <t>Type: TBD3 (See <xref target="IANA"></xref>)</t>

              <t>U: Unassigned bit <xref target="RFC8300"></xref>.</t>

              <t>IV Length: Carries the length of the IV (Section 5.2 of <xref
              target="RFC7518"></xref>). If HMAC algorithm is used, IV length
              is set to zero.</t>

              <t>Initialization Vector: Carries the IV for authenticated
              encryption algorithm as discussed in Section 5.2 of <xref
              target="RFC7518"></xref>.</t>

              <t>The Additional Authenticated Data (defined in <xref
              target="RFC7518"></xref>) MUST be the Service Path header, the
              unencrypted Context headers, and the inner packet on which NSH
              is imposed .</t>

              <t>Message Authentication Code covering the entire NSH data
              excluding the Base header.</t>
            </list></t>
        </section>

        <section anchor="enc2" title="MAC#2 Context Header">
          <t>MAC#2 Context Header is a variable-length TLV that carries the
          MAC for the entire NSH data calculated using MAC_KEY and optionally
          Context Headers encrypted using ENC_KEY. The scope of this TLV is
          depicted in <xref target="scope2"></xref>.</t>

          <figure anchor="scope2" title="Scope of MAC#2">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
   |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Service Path Identifier              | Service Index |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Key Identifier                           ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   ~                      Timestamp                                ~   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |                                                               |   |
   ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
   |                                                               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   |          Metadata Class       |      Type     |U|    Length   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
   | IV Length   |           Initialization Vector                 |   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
|  ~              Context Header TLVs to encrypt                   ~   |
+->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   | 
|  |                                                               |   |
|  ~               Inner Packet on which NSH is imposed            ~   |
|  |                                                               |   |
|  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
|                                                                      |
|                                                                      |
|                                                                      | 
|                                       Integrity protected Portion----+
+----Encrypted Portion     
                
]]></artwork>
          </figure>

          <t></t>

          <t>In reference to <xref target="mac"></xref>, the description of
          the fields is as follows:<list style="symbols">
              <t>Metadata Class: MUST be set to 0x0 <xref
              target="RFC8300"></xref>.</t>

              <t>Type: TBD4 (See <xref target="IANA"></xref>)</t>

              <t>U: Unassigned bit <xref target="RFC8300"></xref>.</t>

              <t>IV Length: Carries the length of the IV (Section 5.2 of <xref
              target="RFC7518"></xref>). If HMAC algorithm is used, IV length
              is set to zero.</t>

              <t>Initialization Vector: Carries the IV for authenticated
              encryption algorithms as discussed in Section 5.2 of <xref
              target="RFC7518"></xref>.</t>

              <t>The Additional Authenticated Data (defined in <xref
              target="RFC7518"></xref>) MUST be the entire NSH data (i.e.,
              including the Base Header) excluding the Context Headers to be
              encrypted.</t>

              <t>Message Authentication Code covering the entire NSH data and
              optional encrypted Context Headers.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="prorules" title="Processing Rules">
      <t>The following sub-sections describe the processing rules for
      integrity protected NSH and optionally encrypted Context Headers.</t>

      <section title="Generic Behavior">
        <t>This document adheres to the recommendations in <xref
        target="RFC8300"></xref> for handling the Context Headers at both
        ingress and egress SFC boundary nodes. That is, to strip such context
        headers.</t>

        <t>Failures to inject or validate the Context Headers defined in this
        document SHOULD be logged locally while a notification alarm MAY be
        sent to an SFC Control Element. Similarly, failure to validate the
        integrity of the NSH data MUST cause that packet to be discarded while
        a notification alarm MAY be sent to an SFC Control Element. The
        details of sending notification alarms (i.e., the parameters affecting
        the transmission of the notification alarms depend on the information
        in the context header such as frequency, thresholds, and content in
        the alarm) SHOULD be configurable by the SFC control plane.</t>

        <t>SFC-aware SFs and SFC proxies MAY be instructed to strip some
        encrypted Context Headers from the packet or to pass the data to the
        next SF in the service function chain after processing the content of
        the Context Headers. If no instruction is provided, the default
        behavior for intermediary SFC-aware nodes is to maintain such Context
        Headers so that the information can be passed to next SFC-aware hops.
        SFC-aware SFs and SFC proxies must re-apply the integrity protection
        if any modification is made to the Context Headers (strip a Context
        Header, update the content of an existing Context Header, insert a new
        Context Header). <!----></t>

        <t>An SFC-aware SF or SFC proxy that is not allowed to decrypt any
        Context Headers MUST NOT be given access to the ENC_KEY.</t>

        <t>Otherwise, an SFC-aware SF or SFC proxy that receives encrypted
        Context Headers, for which it is not allowed to consume a specific
        Context Header it decrypts (but consumes others), MUST keep that
        Context Header unaltered when forwarding the packet upstream.</t>

        <t><!--
--><list style="empty">
            <t>Notes: (1) add more text to handle multiple instances of the
            TLVs, (2) check which actual SFC element is doing what, ...</t>
          </list></t>
      </section>

      <section title="MAC NSH Data Generation">
        <t>If the Context Headers are not encrypted, the HMAC algorithm
        discussed in <xref target="RFC4868"></xref> is used to integrity
        protect the target NSH data. An NSH imposer inserts a "MAC and
        Encrypted Metadata" Context Header for integrity protection (<xref
        target="enc"></xref>).</t>

        <t>The NSH imposer computes the message integrity for the target NSH
        data (depending on the integrity protection scope discussed in <xref
        target="enc"></xref>) using MAC_KEY and HMAC algorithm. It inserts the
        MAC in the "MAC and Encrypted Metadata" Context Header. The length of
        the MAC is decided by the HMAC algorithm adopted for the particular
        key identifier.</t>

        <t>The Message Authentication Code T computation process can be
        illustrated as follows:</t>

        <figure>
          <artwork><![CDATA[      T = HMAC-SHA-256-128(MAC_KEY, A)
]]></artwork>
        </figure>

        <t></t>

        <t>An entity in the SFP that intends to update NSH MUST follow the
        above behavior to maintain message integrity of the NSH for subsequent
        validations.</t>
      </section>

      <section title="Encrypted NSH Metadata Generation">
        <t>An NSH imposer can encrypt Context Headers carrying
        privacy-sensitive metadata, i.e., encrypted and unencrypted metadata
        may be carried simultaneously (<xref target="up"></xref>).</t>

        <figure anchor="up"
                title="NSH with Encrypted and Unencrypted Metadata">
          <artwork><![CDATA[      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Service Path Identifier              | Service Index |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
     ~                      Key Identifier                           ~
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ~                      Timestamp                                ~
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~       Variable-Length Unencrypted Context Headers  (opt.)     ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~                   MAC and Encrypted Metadata                  ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <t></t>

        <t>In an SFC-enabled domain where pervasive monitoring <xref
        target="RFC7258"></xref> is possible, Context Headers carrying
        privacy-sensitive metadata MUST be encrypted and MUST NOT reveal
        privacy-sensitive metadata to attackers. Privacy specific threats are
        discussed in Section 5.2 of <xref target="RFC6973"></xref>.</t>

        <t>Using K and authenticated encryption algorithm, the NSH imposer
        encrypts the Context Headers (as set by the control plane <xref
        target="req"></xref>), computes the message integrity for the target
        NSH data and inserts the resulting payload in the "MAC and Encrypted
        Metadata" Context Header (<xref target="enc"></xref>). The entire TLV
        carrying the privacy-sensitive metadata is encrypted (that is,
        including the MD Class, Type, Length, and associated metadata).</t>

        <t>The message Authentication Tag T and ciphertext E computation
        process can be illustrated as follows.</t>

        <figure>
          <artwork><![CDATA[      MAC_KEY = initial MAC_KEY_LEN octets of K,
      ENC_KEY = final ENC_KEY_LEN octets of K,
      E = CBC-PKCS7-ENC(ENC_KEY, P),
      M = MAC(MAC_KEY, A || IV || E || AL),
      T = initial T_LEN octets of M. 
      MAC and Encrypted Metadata = E || T  
]]></artwork>
        </figure>

        <t></t>

        <t>As specified in <xref target="RFC7518"></xref>, the octet string AL
        is equal to the number of bits in the Additional Authenticated Data
        (A) expressed as a 64-bit unsigned big-endian integer.</t>

        <t>An authorized entity in the SFP that intends to update the content
        of an encrypted Context Header or needs to add encrypted Context
        Header MUST also follow the aforementioned behavior.</t>

        <t>An SFF or SFC-aware SF or SFC proxy that only has access to the
        MAC_KEY but not the ENC_KEY computes the message Authentication Tag
        (T) after decrementing the TTL (by the SFF) or SI (SF or SFC proxy)
        and replaces the authentication tag in the NSH with the computed
        authentication tag. Similarly, an SFC-aware SF or SFC proxy that does
        not modify the encrypted Context headers also follows the
        aforementioned behavior.</t>

        <t>The message Authentication Tag (T) computation process can be
        illustrated as follows:</t>

        <t><figure>
            <artwork><![CDATA[      M = MAC(MAC_KEY, A || IV || E || AL), 
      T = initial T_LEN octets of M. 
]]></artwork>
          </figure></t>
      </section>

      <section anchor="time" title="Timestamp for Replay Attack">
        <t><!--15.  Section 7.4, I would also say what happens when sequence number holes are seen, and if out-of-order packets 
are supposed to be re-ordered (or not supposed to be re-ordered).  We know how that should work, but I would add a
 'todo' so that text gets thrown in.  Some implementers will get excited about sequence number, --><!--thinking it could fix problems for them, when the mis-ordering actually occurs before the packet arrives at the NSH Imposer!--><!--
-->A Timestamp is an unsigned 64-bit integer value and is expressed in seconds
        relative to 1970-01-01T00:00Z in UTC time. The information MUST always
        be present. The received NSH is accepted if the Timestamp (TS) in the
        NSH is recent enough to the reception time of the NSH (TSrt). The
        following formula is used for this check:</t>

        <t><figure>
            <artwork><![CDATA[          -Delta < (TSrt ? TS) < +Delta
]]></artwork>
          </figure></t>

        <t>The RECOMMENDED value for the allowed Delta is 2 seconds. If the
        timestamp is not within the boundaries, then the SFC data plane
        element receiving such packet MUST discard the NSH message.</t>

        <t>In order to synchronize the time, all SFC data plane elements need
        to be configured to point to a NTP server that will provide clocking
        to all the devices.</t>
      </section>

      <section title="NSH Data Validation">
        <t>When an SFC data plane element receives an NSH, it MUST first
        ensure that all mandatory Context Headers required for NSH data
        integrity are included. It MUST discard the message, if one of these
        mandatory Context Headers is absent or if the timestamp is invalid
        (described in <xref target="time"></xref>). Otherwise, the SFC data
        plane element should then proceed with NSH data integrity validation.
        The SFC data plane element computes the message integrity for the
        target NSH data (depending on the integrity protection scope discussed
        in <xref target="enc"></xref>) using the MAC_KEY and HMAC algorithm
        for the key identifier. If the value of the newly generated digest is
        identical to the one enclosed in NSH, the SFC data plane element is
        certain that the NSH data has not been tampered and validation is
        therefore successful. Otherwise, the NSH message MUST be
        discarded.</t>
      </section>

      <section title="Decryption of NSH Metadata">
        <t>If entitled to consume a supplied encrypted Context Header, an
        SFC-aware SF or SFC proxy decrypts metadata using K and decryption
        algorithm for the key identifier in NSH.</t>

        <t>Authenticated encryption algorithm has only a single output, either
        a plaintext or a special symbol FAIL that indicates that the inputs
        are not authentic (Section 5.2.2.2 of <xref
        target="RFC7518"></xref>).</t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>NSH security considerations are discussed in Section 8 of <xref
      target="RFC8300"></xref>. The guidelines for cryptographic key
      management are discussed in <xref target="RFC4107"></xref>.</t>

      <t>The interaction between the SFC-aware data plane elements and a key
      management system MUST NOT be transmitted in clear since this would
      completely destroy the security benefits of the integrity protection
      solution defined in this document. The secret key K must have an
      expiration time assigned as the latest point in time before which the
      key may be used for integrity protection of NSH data and encryption of
      Context Headers. Prior to the expiration of the secret key, all
      participating service function nodes SHOULD have the control plane
      distribute an new key identifier and associated keying material, so that
      when the secret key is expired those nodes are prepared with the new
      secret key. This allows the NSH Imposer to switch to the new key
      identifier as soon as necessary. It is RECOMMENDED that the next key
      identifier be distributed by the control plane well prior to the secret
      key expiration time.</t>

      <t>NSH data are exposed to several threats:</t>

      <t><list style="symbols">
          <t>A man-in-the-middle attacker modifying NSH data.</t>

          <t>Attacker spoofing NSH data.</t>

          <t>Attacker capturing and replaying NSH data.</t>

          <t>Metadata in Context Headers revealing privacy-sensitive
          information to attackers.</t>

          <t>Attacker replacing the packet on which NSH is imposed with a
          bogus or malicious packet.</t>
        </list></t>

      <t>In an SFC-enabled domain where the above attacks are possible, NSH
      data MUST be integrity-protected and replay-protected, and
      privacy-sensitive NSH metadata MUST be encrypted for confidentiality
      preservation purposes. The Base and Service Path headers are not
      encrypted.</t>

      <t>Two MAC flavors are defined in <xref target="enc"></xref>.
      Considerations specific to each flavor are discussed in the following
      sub-sections.</t>

      <section anchor="mac1" title="MAC#1">
        <t>An active attacker can potentially modify the Base header (e.g.,
        decrement the TTL so the next SFF in the SFP discards the NSH packet).
        In the meantime, an active attacker can also drop NSH packets. As
        such, this attack is not considered an attack against the security
        mechanism specified in the document.</t>

        <t>No device other than the SFC-aware SFs in the SFC-enabled domain
        should be able to update the integrity protected NSH data. Similarly,
        no device other than the SFC-aware SFs and SFC proxies in the
        SFC-enabled domain be able to decrypt and update the Context Headers
        carrying privacy-sensitive metadata. In other words, if the SFC-aware
        SFs and SFC proxies in the SFC-enabled domain are considered fully
        trusted to act on the NSH data, only they can have access to
        privacy-sensitive NSH metadata and the keying material used to
        integrity protect NSH data and encrypt Context Headers.</t>
      </section>

      <section anchor="mac2" title="MAC#2">
        <t>SFFs can detect whether an illegitimate node has altered the
        content of the Base header. Such messages MUST be discarded with
        appropriate logs and alarms generated.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document requests IANA to assign the following types from the
      "NSH IETF-Assigned Optional Variable-Length Metadata Types" (0x0000 IETF
      Base NSH MD Class) registry available at:
      https://www.iana.org/assignments/nsh/nsh.xhtml#optional-variable-length-metadata-types.</t>

      <t><figure>
          <artwork><![CDATA[+-------+-------------------------------+----------------+
| Value | Description                   | Reference      |
+-------+-------------------------------+----------------+
| TBD1  | Key Identifier                | [ThisDocument] |
| TBD2  | Timestamp                     | [ThisDocument] |
| TBD3  | MAC and Encrypted Metadata#1  | [ThisDocument] |
| TBD4  | MAC and Encrypted Metadata#2  | [ThisDocument] |
+-------+-------------------------------+----------------+]]></artwork>
        </figure></t>
    </section>

    <section title="Acknowledgements">
      <t>This document was edited as a follow up to the discussion in
      IETF#104:
      https://datatracker.ietf.org/meeting/104/materials/slides-104-sfc-sfc-chair-slides-01
      (slide 7).</t>

      <t>Thanks to Joel Halpern, Christian Jacquenet, and Dirk von Hugo for
      the comments.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.8300"?>

      <?rfc include='reference.RFC.7665'?>

      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include='reference.RFC.4868'?>

      <?rfc include='reference.RFC.7518'?>

      <?rfc include='reference.RFC.4107'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.8459"?>

      <?rfc include='reference.RFC.7498'?>

      <?rfc include="reference.RFC.7258"?>

      <?rfc include="reference.RFC.6973"?>

      <?rfc include='reference.I-D.arkko-arch-internet-threat-model'?>

      <!---->
    </references>

    <section anchor="example" title="A Deployment Example with KMS">
      <t>In this deployment example, SFC-aware SFs do not share any
      credentials; instead, they trust a third party, the KMS (Key Management
      System), with which they have or can establish shared credentials. These
      pre-established trust relations are used to establish a security
      association between SFC data plane elements within the context of a
      given service chain.</t>

      <t>If the Context Headers are to be encrypted, the NSH imposer requests
      a secret key for a authenticated encryption algorithm and key identifier
      from the KMS. If the Context Headers are not to be encrypted, NSH
      imposer requests a secret key for a HMAC algorithm and key identifier
      from the KMS. The request message also includes identities of the SFC
      data plane elements (including SFC-aware SFs and SFC proxies) authorized
      to receive the keying material (secret key, expiration time and
      authenticated encryption or HMAC algorithm) associated with the key
      identifier. Each SFC-aware SF is referenced using an SF identifier that
      is unique within an SFC-enabled domain. If the request is authorized,
      then KMS generates the secret key, key identifier (kid), and returns
      them in a response message. The secondary keys MAC_KEY and ENC_KEY are
      generated from the secret key. The key identifier may be self-contained
      (key encrypted in the key identifier) or just a handle to some internal
      data structure within the KMS.</t>

      <t>The NSH imposer includes the key identifier in NSH data. The NSH data
      is protected using MAC_KEY and Context Headers are encrypted using
      ENC_KEY. SFC-aware SFs and SFC proxies in the SFP forward the key
      identifier to the KMS and request the KMS to retrieve the keying
      material. If the SFC data plane element is authorized and the key
      identifier is valid, then the KMS retrieves the secret key and
      authenticated encryption algorithm associated with the key identifier
      and conveys them to the SFC data plane element. If the SFC data plane
      element is authorised to compute the message integrity of NSH data but
      not authorized to decrypt the Context Headers and the key identifier is
      valid, then the KMS retrieves the MAC_KEY and authenticated encryption
      algorithm associated with the key identifier and conveys them to the SFC
      data plane element. The other alternative approach is that KMS
      implicitly pushes the keying material to, particularly, SFFs, SFC-aware
      SFs and SFC proxies authorized by the NSH imposer.</t>

      <t>If the NSH imposer requests a new key and a new key identifier from
      KMS, the request message from NSH imposer to KMS also includes
      identities of SFFs, SFC-aware SFs and SFC proxies authorized to receive
      the keying material associated with the new key identifier. For
      subsequent packets, the new key identifier will be conveyed in the NSH
      data, NSH data will be integrity protected using the new MAC_KEY and
      Context Headers are encrypted using the new ENC_KEY.</t>

      <t><xref target="figure1"></xref> shows an example of an NSH imposer
      requesting secret key and key identifier from the KMS. The request
      message includes identifiers of SF1 and SF2 Service Functions authorized
      to receive keying material associated with the key identifier. KMS
      returns the secret key and key identifier in the response message. The
      NSH imposer includes the key identifier in the NSH data. In this
      example, SF1 in the SFP forwards the key identifier to the KMS and
      requests the KMS for keying material associated with the key identifier
      (In key resolve request message). If SF1 is authorized and the key
      identifier is valid then KMS retrieves the keying material associated
      with the key identifier and conveys them to the SF1 (In Resolve response
      message). Similarly, SF2 retrieves the keying material associated with
      the key identifier from KMS. <list style="empty">
          <t>Note: Update the example with the SFF</t>
        </list></t>

      <t>The exchange with KMS is not required if the necessary information is
      pre-provisonned to the authorized SFFs, SFC-aware SFs and SFC
      proxies.</t>

      <t><figure anchor="figure1" title="Example of Interactions with KMS">
          <artwork><![CDATA[
+----------------+            +-------+        +------+       +------+
|   NSH Imposer  |            |  KMS  |        | SF1  |       | SF2  |
+----+-----------+            +----+--+        +----+-+       +--+---+
     |                             |                |            |    
     |                             |                |            |    
     |   Key Request               |                |            |    
     +---------------------------->|                |            |    
     |                             |                |            |    
     |   Key Response              |                |            |    
     |<----------------------------+                |            |    
     |                             |                |            |    
     | Key Identifier sent in NSH  |                |            |    
     +--------------------------------------------->+----------->|    
     |                             |                |            |    
     |                             | Key Resolve    |            |    
     |                             |<---------------+            |    
     |                             |                |            |    
     |                             | Resolve response            |    
     |                             +--------------->|            |    
     |                             |                |            |    
     |                             | Key resolve    |            |    
     |                             |<----------------------------+    
     |                             | Resolve response            |    
     |                             +---------------------------->|    
     |                             |                |            | ]]></artwork>
        </figure></t>

      <t></t>
    </section>
  </back>
</rfc>
